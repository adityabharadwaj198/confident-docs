---
title: Input/Output
---

import { Callout, Tabs } from "nextra/components";

# Input/Output

Both traces and spans have inputs and outputs, which you can set dynamically within your application using the `update_current_span` and `update_current_trace` function respectively.

## Set Trace I/O At Runtime

You can set the `input` and `output` of a trace using the `update_current_trace` function:

<Tabs items={['Python', 'JS/TypeScript']}>
  <Tabs.Tab>
    ```python showLineNumbers {13}
    from deepeval.tracing import observe, update_current_trace
    import openai
     
    @observe()
    def llm_app(query: str):
        res = openai.ChatCompletion.create(
            model="gpt-4o",
            messages=[
                {"role": "user", "content": query}
            ]
        ).choices[0].message["content"]
    
        update_current_trace(input=query, output=res)
        return res
     
     
    llm_app("Write me a poem.")
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```typescript showLineNumbers {13}
    import { observe, updateCurrentTrace } from '@confident/tracing';
    import OpenAI from 'openai';
    
    const openai = new OpenAI();
    
    const llmApp = (query: string): string => {
      const res = openai.chat.completions.create({
        model: "gpt-4o",
        messages: [
          { role: "user", content: query }
        ]
      }).choices[0].message.content;
      updateCurrentTrace({ input: query, output: res });
      return res;
    };
    
    const observedLlmApp = observe({
        fn: llmApp
    });
    
    observedLlmApp("Write me a poem.");
    ```
  </Tabs.Tab>
</Tabs>

The `input` and `output` can be **ANY TYPE**, and is useful for visualization on the UI (even more so if you're using [conversation threads](/llm-tracing/tracing-features/threads)).

<Callout>
The trace I/O defaults to the `input` and `output` of the root span **if not set.**
</Callout>

## Set Span I/O At Runtime


You can set the `input` and `output` on spans using the `update_current_span` function.

One thing to note however, is we recommend [setting attributes](/llm-tracing/tracing-features/attributes) instead of `input` and `output` directly on spans that are one of the **DEFAULT span types**, since DeepEval handles the `input` and `output` setting automatically for default span `type`s. 

<Callout type="warning">
For example, the `"retriever"` span `type` expects a string as the `input` and list of strings as the `output`, which you might violate if setting I/O yourself. This will decrease the chances that you run into an error.
</Callout>

<Tabs items={['Python', 'JS/TypeScript']}>
  <Tabs.Tab>
    ```python showLineNumbers {13}
    from deepeval.tracing import observe, update_current_span
    import openai
     
    @observe()
    def llm_app(query: str):
        res = openai.ChatCompletion.create(
            model="gpt-4o",
            messages=[
                {"role": "user", "content": query}
            ]
        ).choices[0].message["content"]
    
        update_current_span(input=query, output=res)
        return res
     
     
    llm_app("Write me a poem.")
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```typescript showLineNumbers {13}
    import { observe, updateCurrentSpan } from '@confident/tracing';
    import OpenAI from 'openai';
    
    const openai = new OpenAI();
    
    const llmApp = (query: string): string => {
      const res = openai.chat.completions.create({
        model: "gpt-4o",
        messages: [
          { role: "user", content: query }
            ]
        }).choices[0].message.content;
      updateCurrentSpan({ input: query, output: res });
      return res;
    };
    
    const observedLlmApp = observe({
        fn: llmApp
    });
    
    observedLlmApp("Write me a poem.");
    ```
  </Tabs.Tab>
</Tabs>

This example is the same as the one for tracing except for the `update_current_trace`, and that's not a mistake. You can set `input` and `output`s the same way as you do for traces, and if a trace's I/O is not set it defaults to the I/O of the root span.

The `input` and `output` can be **ANY TYPE** for custom span `type`s, and is useful for visualization on the UI.
